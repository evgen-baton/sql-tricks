# Генерация данных
Иногда требуется использовать сгенерированные данные для построения корректной выборки.
Например вам нужен массив дат на каждй день прошедших двух недель.

## MSSQL
Рекурсивная генерация дат
```sql
DECLARE @start_date date = DATEADD(day, -14, CAST(GETDATE() as date)) -- Выбирает стартовую дату (текущая минус 14 дней)
DECLARE @end_date date= CAST(GETDATE() as date) -- Выбирает конечную дату (текущая)
;WITH dates AS (
    SELECT @start_date AS period_start
    UNION ALL
    SELECT DATEADD(day, 1, period_start)
    FROM dates
    WHERE DATEADD(day, 1, period_start) <= @end_date
)
SELECT * FROM dates
```

## PgSQL
Использование функции `generate_series`
```sql
with dates as (
    select gs::date period_start
    from generate_series(
                 date_trunc('week', now() - interval '2 week'), -- Выбирает стартовую дату (текущая минус 2 недели)
                 date_trunc('week', now()), -- Выбирает конечную дату (текущая)
                 interval '1 day') as gs -- Интервал 1 день
)
select * from dates
```

Результатом работы обоих решений будет таблица
| period_start |
| ------------ |
| 2020-11-09   |
| 2020-11-10   |
| 2020-11-11   |
| 2020-11-12   |
| 2020-11-13   |
| 2020-11-14   |
| 2020-11-15   |
| 2020-11-16   |
| 2020-11-17   |
| 2020-11-18   |
| 2020-11-19   |
| 2020-11-20   |
| 2020-11-21   |
| 2020-11-22   |
| 2020-11-23   |

## Пример использования
Предположим у вас есть сайт - доска объявлений. Все объявления пользователей хранятся в табличке public.offers. Ваша задача - посчитать количество размещенных каждый день объявлений.
Пример таблицы public.offers
| id  | user_id | created_date |
| --- | ------- | ------------ |
| 1   | 12      | 2020-11-09   |
| 2   | 22      | 2020-11-09   |
| 3   | 33      | 2020-11-11   |
| 4   | 44      | 2020-11-12   |
| 5   | 55      | 2020-11-12   |

Задачу можно было бы решить простым SQL
```sql
select o.created_date target_date,
       count(*) offers_quantity
from public.offers o
group by o.created_date
```
Но в таком случае вы потеряете информацию о 2020-11-10, так как в этот день не было размещения объявлений на вашем сайте. При построении графика мы увидим разрыв. Нам важно явно указать что 2020-11-10 было 0 размещений
```sql
with dates as (
    select gs::date period_start
    from generate_series(
                 date_trunc('week', now() - interval '2 week'), -- Выбирает стартовую дату (текущая минус 2 недели)
                 date_trunc('week', now()), -- Выбирает конечную дату (текущая)
                 interval '1 day') as gs -- Интервал 1 день
)
select da.period_start target_date,
       count(o.Id) offers_quantity
from dates da
left join public.offers o 
    on da.period_start = o.created_date
group by da.period_start
```
Такой запрос должен вернуть вам таблицу в которой будут данные на каждый день из 14ти сгенерированных через `generate_series` функцию


# Как развернуть данные из файла в таблицу
Часто строить аналитику необходимо по определенному списку пользователей. Такой список вам может предоставить кто-то из команды, компании или вы сами. Возможно собрать список пользователей необходимо в одной базе данных, а строить выборку в другой.
Такую проблему можно решить несколькими способами:
- Создать новую таблицу и наполнить ее данными из списка (например через импорт из плоского файла)
- В условии `Where` запроса на аналитику добавить фильтрацию по пользователяем (`Where UserId in (1,2,3,4)`)
- Использовать оператор `Values`

Не всегда есть возможность создать таблицу, а пользоваться условием where удобно если список пользователей очень сильно ограничен - иначе читаемость запроса начнет сильно падать.

## MSSQL и PgSQL
В обеих СУБД запрос реализуется одинаково
```sql
select *
from (values
    (1,'test@ya.ru'), (2, 'another@mail.ru'), (3, 'some-other@mail.ru'))
    x (user_id, email)
```
Результатом работы станет табличка ниже. Заметьте, вы можете добавить любые данные в выборку и управлять названием поля через алиас `x (user_id, email)`
| user_id | email              |
| ------- | ------------------ |
| 1       | test@ya.ru         |
| 2       | another@mail.ru    |
| 3       | some-other@mail.ru |

## Пример использования
Предположим у вас есть сайт - доска объявлений. Все объявления пользователей хранятся в табличке public.offers. Ваш менеджер не понимает и не разбирается в id пользователей. Поэтому просит вас пользоваться email пользователей. Вам необходимо вывести список `email_пользователя,количество_объявлений` по заранее подготовленному списку данных
Пример таблицы public.offers
| id  | user_id | created_date |
| --- | ------- | ------------ |
| 1   | 12      | 2020-11-09   |
| 2   | 22      | 2020-11-09   |
| 3   | 33      | 2020-11-11   |
| 4   | 44      | 2020-11-12   |
| 5   | 44      | 2020-11-12   |
Для того чтобы улучшить читаемость кода, разобьем запрос на две части:
- Выборка данных по пользователю
- Выборка данных объявлений

```sql
/* Пользовательские данные */
with users_data as (
    select *
    from (values
        (12,'test@ya.ru'), (22, 'another@mail.ru'), (33, 'some-other@mail.ru')), (44, 'the_greatest@mail.ru'), (55, 'the_longest_email_of_all@mail.ru'))
        x (user_id, email)
)
/* Аналитический запрос */
select ud.email user_email,
       count(o.id) offers_quantity
from users_data ud
inner join public.offers o 
    on ud.user_id = o.user_id
group by ud.email
```
Результатом работы станет табличка ниже. В решении мы с вами постарались отгородить данные пользователей от логики самого запроса. Таким образом если однажды пользовательские данные придется изменить, это будет сделать очень просто. Используя такую технику можно собирать данные из различных источников. Например данные пользователей можно выгрузить из СУБД MSSQL, а данные объявлений из СУБД PgSql
| user_email           | offers_quantity |
| -------------------- | --------------- |
| test@ya.ru           | 1               |
| another@mail.ru      | 1               |
| some-other@mail.ru   | 1               |
| the_greatest@mail.ru | 2               |
